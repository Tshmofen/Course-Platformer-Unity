using System.Linq;
using ThirdParty.QPathFinder.Script;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.SceneManagement;
using Logger = ThirdParty.QPathFinder.Script.Logger;

// ReSharper disable once CheckNamespace
namespace QPathFinder
{
    [CustomEditor(typeof(PathFinder))]
    public class PathFinderEditor : Editor
    {
        private enum SceneMode
        {
            AddNode,
            EditNode,
            ConnectPath,
            None
        }

        [MenuItem("GameObject/Create a 2D PathFinder in scene with a collider")]
        public static void Create2DPathFinderObjectInScene()
        {
            if (FindObjectOfType<PathFinder>() == null)
            {
                var managerGo = new GameObject("PathFinder");
                var colliderGo = GameObject.CreatePrimitive(PrimitiveType.Cube);
                colliderGo.name = "Ground";
                colliderGo.GetComponent<Renderer>().sharedMaterial.SetColor(ShaderColor, Color.black);

                colliderGo.transform.localScale = new Vector3(100f, 100f, 1f);
                var boxCollider = colliderGo.AddComponent<BoxCollider>();
                boxCollider.isTrigger = true;

                managerGo.AddComponent<PathFinder>();
            }
            else
            {
                if (Logger.CanLogError) Logger.LogError("PathFollower Script already exists!");
            }
        }

        [MenuItem("GameObject/Create a 3D PathFinder in scene with a collider")]
        public static void Create3DPathFinderObjectInScene()
        {
            if (FindObjectOfType<PathFinder>() == null)
            {
                var managerGo = new GameObject("PathFinder");
                var colliderGo = GameObject.CreatePrimitive(PrimitiveType.Cube);
                colliderGo.name = "Ground";
                colliderGo.GetComponent<Renderer>().sharedMaterial.SetColor(ShaderColor, Color.green);

                colliderGo.transform.localScale = new Vector3(100f, 1f, 100f);
                colliderGo.transform.position = Vector3.down * 20;

                var boxCollider = colliderGo.AddComponent<BoxCollider>();
                boxCollider.isTrigger = true;

                managerGo.AddComponent<PathFinder>();
            }
            else
            {
                if (Logger.CanLogError) Logger.LogError("PathFollower Script already exists!");
            }
        }


        #region OnInspectorGUI

        public override void OnInspectorGUI()
        {
            _showDefaultInspector = EditorGUILayout.Toggle("Show Default inspector", _showDefaultInspector);
            if (_showDefaultInspector)
            {
                DrawDefaultInspector();
            }
            else
            {
                CustomGUI.DrawSeparator(Color.gray);
                ShowNodesAndPathInInspector();
            }
        }

        private void ShowNodesAndPathInInspector()
        {
            _script.graphData.nodeSize = EditorGUILayout.Slider("Node gizmo Size", _script.graphData.nodeSize, 0.1f, 3f);
            _script.graphData.lineColor = EditorGUILayout.ColorField("Path Color", _script.graphData.lineColor);
            _script.graphData.lineType = (PathLineType)EditorGUILayout.EnumPopup("Path Type", _script.graphData.lineType);
            _script.graphData.heightFromTheGround = EditorGUILayout.FloatField("Offset from ground( Height )", _script.graphData.heightFromTheGround);
            _script.graphData.groundColliderLayerName = EditorGUILayout.TextField("Ground collider layer name", _script.graphData.groundColliderLayerName);
            EditorGUILayout.Space();
            GUILayout.Label("<size=12><b>Nodes</b></size>", CustomGUI.GetStyleWithRichText());

            if (_script.graphData.nodes.Count > 0)
            {
                _showNodeIDsInTheScene = EditorGUILayout.Toggle("Show Node IDs in scene", _showNodeIDsInTheScene);

                var nodeList = _script.graphData.nodes;
                for (var j = 0; j < nodeList.Count; j++)
                {
                    GUILayout.BeginHorizontal();
                    {
                        EditorGUILayout.LabelField("\t" + "Node <Color=" + NodeGUITextColor + ">" + nodeList[j].autoGeneratedID + "</Color>", CustomGUI.GetStyleWithRichText(), GUILayout.Width(120f));

                        nodeList[j].SetPosition(EditorGUILayout.Vector3Field("", nodeList[j].Position));
                        EditorGUILayout.LabelField("Enable", EditorStyles.miniLabel, GUILayout.Width(50f)); nodeList[j].SetAsOpen(EditorGUILayout.Toggle(nodeList[j].IsOpen));

                        if (GUILayout.Button("+", GUILayout.Width(25f)))
                            AddNode(nodeList[j].Position + Vector3.right + Vector3.up, j + 1);
                        if (GUILayout.Button("-", GUILayout.Width(25f)))
                            DeleteNode(j);
                    }
                    GUILayout.EndHorizontal();
                }
            }
            else
            {
                EditorGUILayout.LabelField("<Color=green> Nodes are empty. Use <b>Add Node</b> in scene view to create Nodes!</Color>", CustomGUI.GetStyleWithRichText(CustomGUI.SetAlignmentForText(TextAnchor.MiddleCenter)));
            }
            EditorGUILayout.Space();
            GUILayout.Label("<size=12><b>Paths</b></size>", CustomGUI.GetStyleWithRichText());

            if (_script.graphData.paths.Count > 0)
            {
                _showPathIDsInTheScene = EditorGUILayout.Toggle("Show Path IDs in scene", _showPathIDsInTheScene);
                _drawPathsInTheScene = EditorGUILayout.Toggle("Draw Paths", _drawPathsInTheScene);
                _showCostsInTheScene = EditorGUILayout.Toggle("Show Path Costs in scene", _showCostsInTheScene);

                var paths = _script.graphData.paths;
                for (var j = 0; j < paths.Count; j++)
                {
                    GUILayout.BeginHorizontal();
                    {
                        EditorGUILayout.LabelField("\t" + "Path <Color=" + PathGUITextColor + ">" + paths[j].autoGeneratedID + "</Color>", CustomGUI.GetStyleWithRichText(), GUILayout.Width(120f));

                        EditorGUILayout.LabelField("From", EditorStyles.miniLabel, GUILayout.Width(30f)); paths[j].IDOfA = EditorGUILayout.IntField(paths[j].IDOfA, GUILayout.Width(50f));
                        EditorGUILayout.LabelField("To", EditorStyles.miniLabel, GUILayout.Width(25f)); paths[j].IDOfB = EditorGUILayout.IntField(paths[j].IDOfB, GUILayout.Width(50f));
                        EditorGUILayout.LabelField("<Color=" + CostGUITextColor + ">" + "Cost" + "</Color>", CustomGUI.GetStyleWithRichText(EditorStyles.miniLabel), GUILayout.Width(30f)); paths[j].cost = EditorGUILayout.IntField(paths[j].cost, GUILayout.Width(50f));

                        EditorGUILayout.LabelField("One Way", EditorStyles.miniLabel, GUILayout.Width(50f)); paths[j].isOneWay = EditorGUILayout.Toggle(paths[j].isOneWay);
                        EditorGUILayout.LabelField("Enable", EditorStyles.miniLabel, GUILayout.Width(50f)); paths[j].isOpen = EditorGUILayout.Toggle(paths[j].isOpen);

                        if (GUILayout.Button("+", GUILayout.Width(25f)))
                            AddPath(j + 1);
                        if (GUILayout.Button("-", GUILayout.Width(25f)))
                            DeletePath(j);
                    }
                    GUILayout.EndHorizontal();
                }
            }
            else
            {
                EditorGUILayout.LabelField("<Color=green> Paths are empty. Use <b>Connect Nodes</b> in scene view to create Paths!</Color>", CustomGUI.GetStyleWithRichText(CustomGUI.SetAlignmentForText(TextAnchor.MiddleCenter)));
            }

            if (GUI.changed)
                MarkThisDirty();
        }

        #endregion

        #region On Scene Rendering and Scene GUI

        private void OnSceneGUI()
        {
            var controlID = GUIUtility.GetControlID(FocusType.Passive);
            HandleUtility.AddDefaultControl(controlID);
            DrawGUIWindowOnScene();
            UpdateMouseInput();

            switch (_sceneMode)
            {
                case SceneMode.AddNode:
                    DrawNodes(Color.green);
                    break;
                case SceneMode.EditNode:
                    DrawNodes(Color.magenta, true);
                    break;
                case SceneMode.ConnectPath:
                    DrawNodes(Color.green,
                        false, 
                        _script.graphData.GetNode(_selectedNodeForConnectNodesMode),
                        Color.red
                        );
                    break;
                default:
                    DrawNodes(Color.gray);
                    break;
            }
            DrawPathLine();
            CheckGUIChanged();
        }

        private static void CheckGUIChanged()
        {
            if (GUI.changed)
            {
                SceneView.RepaintAll();
            }
        }
        
        private void DrawGUIWindowOnScene()
        {
            GUILayout.Window(
                1,
                new Rect(0f, 25f, 70f, 80f), 
                delegate
                {
                    EditorGUILayout.BeginHorizontal();
                    _sceneMode = (SceneMode)GUILayout.SelectionGrid(
                        (int)_sceneMode,
                        new[]
                        {
                            "Add Node",
                            "Move Node",
                            "Connect Nodes",
                            "None"
                        }
                        , 1
                        );
                    GUI.color = Color.white;
                    EditorGUILayout.EndHorizontal();
                }, 
                "Mode"
                );
            GUILayout.Window(2,
                new Rect(0, 155f, 70f, 80f),
                delegate
                {
                    EditorGUILayout.BeginVertical();
                    if (GUILayout.Button("Delete Last Node"))
                        DeleteNode();
                    if (GUILayout.Button("Delete Last Path"))
                        DeletePath();
                    if (GUILayout.Button("Clear All"))
                    {
                        ClearNodes();
                        ClearPaths();
                    }
                    if (GUILayout.Button("Refresh Data"))
                    {
                        _script.graphData.ReGenerateIDs();
                    }
                    GUI.color = Color.white;
                    EditorGUILayout.EndVertical();
                }, 
                "");
        }

        private void DrawNodes(
            Color color,
            bool canMove = false, 
            Node selectedNode = null, 
            Color colorForSelected = default
            )
        {
            Handles.color = color;
            foreach (var node in _script.graphData.nodes)
            {
                if (selectedNode != null && node == selectedNode)
                    Handles.color = colorForSelected;
                else
                    Handles.color = color;

                if (canMove)
                {
                    node.SetPosition(
                        Handles.FreeMoveHandle(
                            node.Position,
                            Quaternion.identity,
                            _script.graphData.nodeSize,
                            Vector3.zero,
                            Handles.SphereHandleCap
                        )
                    );
                }
                else
                {
                    Handles.SphereHandleCap(
                        0,
                        node.Position,
                        Quaternion.identity,
                        _script.graphData.nodeSize,
                        EventType.Repaint
                        );
                }
            }
            Handles.color = Color.white;
            DrawGUIDisplayForNodes();
            Handles.color = Color.white;
        }

        private void DrawPathLine()
        {
            var paths = _script.graphData.paths;
            var nodes = _script.graphData.nodes;

            if (paths == null || nodes == null)
                return;

            Handles.color = _script.graphData.lineColor;

            foreach (var path in paths.Where(path => path.isOpen))
            {
                Node a = null, b = null;
                if (_script.graphData.nodesSorted.ContainsKey(path.IDOfA))
                    a = _script.graphData.nodesSorted[path.IDOfA];

                if (_script.graphData.nodesSorted.ContainsKey(path.IDOfB))
                    b = _script.graphData.nodesSorted[path.IDOfB];

                if (a != null && b != null && a != b && a.IsOpen && b.IsOpen)
                {
                    if (_drawPathsInTheScene)
                        Handles.DrawLine(a.Position, b.Position);

                    Handles.BeginGUI();
                    {
                        var currNode = (a.Position + b.Position) / 2;
                        var guiPosition = HandleUtility.WorldToGUIPoint(currNode);
                        var str = "";
                        if (_showPathIDsInTheScene)
                            str += "<Color=" + PathGUITextColor + ">" + path.autoGeneratedID + "</Color>";
                        if (_showCostsInTheScene)
                        {
                            if (!string.IsNullOrEmpty(str))
                                str += "<Color=" + "#ffffff" + ">" + "  Cost: " + "</Color>";
                            str += "<Color=" + CostGUITextColor + ">" + path.cost + "</Color>";
                        }

                        if (!string.IsNullOrEmpty(str))
                        {
                            GUI.Label(
                                new Rect(guiPosition.x - 10, guiPosition.y - 30, 40, 20),
                                str,
                                CustomGUI.GetStyleWithRichText()
                            );
                        }
                    }
                    Handles.EndGUI();
                }
            }
            Handles.color = Color.white;
        }

        private void DrawGUIDisplayForNodes()
        {
            if (!_showNodeIDsInTheScene)
                return;

            Handles.BeginGUI();

            foreach (var currNode in _script.graphData.nodes)
            {
                var guiPosition = HandleUtility.WorldToGUIPoint(currNode.Position);
                GUI.Label(
                    new Rect(guiPosition.x - 10, guiPosition.y - 30, 20, 20),
                    "<Color=" + NodeGUITextColor + ">" + currNode.autoGeneratedID + "</Color>",
                    CustomGUI.GetStyleWithRichText()
                    );
            }
            Handles.EndGUI();
        }

        #endregion

        #region Input Method

        private void UpdateMouseInput()
        {
            var e = Event.current;
            switch (e.type)
            {
                case EventType.MouseDown:
                {
                    if (e.button == 0)
                        OnMouseClick(e.mousePosition);
                    break;
                }
                case EventType.MouseUp:
                    MarkThisDirty();
                    SceneView.RepaintAll();
                    break;
            }
        }

        private void OnMouseClick(Vector2 mousePos)
        {
            switch (_sceneMode)
            {
                case SceneMode.AddNode:
                {
                    LayerMask backgroundLayerMask = 
                        1 << LayerMask.NameToLayer(_script.graphData.groundColliderLayerName);
                    var ray = HandleUtility.GUIPointToWorldRay(mousePos);

                    if (Physics.Raycast(ray, out var hit, 100000f, backgroundLayerMask))
                    {
                        var hitPos = hit.point;
                        hitPos += (-ray.direction.normalized) * _script.graphData.heightFromTheGround;
                        AddNode(hitPos);
                    }
                    else
                    {
                        Logger.LogError("No collider detected with layer "
                                        + _script.graphData.groundColliderLayerName
                                        + "! Could not add node! ");
                    }
                    break;
                }
                case SceneMode.ConnectPath:
                {
                    LayerMask backgroundLayerMask = 
                        1 << LayerMask.NameToLayer(_script.graphData.groundColliderLayerName);
                    var ray = HandleUtility.GUIPointToWorldRay(mousePos);

                    if (Physics.Raycast(ray, out var hit, 1000f, backgroundLayerMask))
                    {
                        var hitPos = hit.point;
                        TryAddPath(hitPos);
                    }
                    else
                    {
                        Logger.LogError("No collider detected with layer "
                                        + _script.graphData.groundColliderLayerName
                                        + "! Could not add node! ");
                    }
                    break;
                }
            }
        }

        #endregion
        
        #region Node and Path methods

        private void AddNode(Vector3 position, int addIndex = -1)
        {
            var nodeAdded = new Node(position);
            if (addIndex == -1)
                _script.graphData.nodes.Add(nodeAdded);
            else
                _script.graphData.nodes.Insert(addIndex, nodeAdded);

            _script.graphData.ReGenerateIDs();

            Logger.LogInfo("Node with ID:" + nodeAdded.autoGeneratedID + " Added!");
        }

        private void DeleteNode(int removeIndex = -1)
        {
            var nodeList = _script.graphData.nodes;
            if (nodeList == null || nodeList.Count == 0)
                return;

            if (removeIndex == -1)
                removeIndex = nodeList.Count - 1;

            var nodeRemoved = nodeList[removeIndex];
            nodeList.RemoveAt(removeIndex);
            _script.graphData.ReGenerateIDs();

            Logger.LogInfo("Node with ID:" + nodeRemoved.autoGeneratedID + " Removed!");
        }

        private void ClearNodes()
        {
            _script.graphData.nodes.Clear();
            Logger.LogWarning("All Nodes are cleared!");
        }

        private void AddPath(int addIndex = -1, int from = -1, int to = -1)
        {
            if (from != -1 && to != -1)
            {
                if (from == to)
                {
                    Logger.LogError("Preventing from adding Path to the same node.");
                    return;
                }
                var pd = _script.graphData.GetPathBetween(from, to);
                if (pd != null)
                {
                    Logger.LogError("We already have a path between these nodes. New Path not added!");
                    return;
                }
            }
            var newPath = new Path(from, to);
            if (addIndex == -1)
                _script.graphData.paths.Add(newPath);
            else
                _script.graphData.paths.Insert(addIndex, newPath);
            _script.graphData.ReGenerateIDs();

            Logger.LogInfo("Path with ID:" + newPath.autoGeneratedID + " Added");
        }

        private void DeletePath(int removeIndex = -1)
        {
            var pathList = _script.graphData.paths;
            if (pathList == null || pathList.Count == 0)
                return;

            if (removeIndex == -1)
                removeIndex = pathList.Count - 1;

            var removedPath = pathList[removeIndex];
            pathList.RemoveAt(removeIndex);
            _script.graphData.ReGenerateIDs();

            Logger.LogInfo("Path with ID:" + removedPath.autoGeneratedID + " Removed");
        }

        private void ClearPaths()
        {
            _script.graphData.paths.Clear();
            Logger.LogWarning("All Paths are cleared!");
        }

        private void TryAddPath(Vector3 position)
        {
            var selectedNode = _script.graphData.GetNode(_script.FindNearestNode(position));
            if (selectedNode == null)
            {
                Logger.LogError("Could not find any nearest Node to connect to!");
                return;
            }
            if (_selectedNodeForConnectNodesMode != -1)
            {
                AddPath(-1, _selectedNodeForConnectNodesMode, selectedNode.autoGeneratedID);
                Logger.LogInfo("Connected " + _selectedNodeForConnectNodesMode + " and " + selectedNode.autoGeneratedID);
                _selectedNodeForConnectNodesMode = -1;
            }
            else
            {
                _selectedNodeForConnectNodesMode = selectedNode.autoGeneratedID;
                Logger.LogInfo("Selected : " + _selectedNodeForConnectNodesMode + ". Now click another node to join these two");
            }
        }

        #endregion

        #region PRIVATE

        private void OnEnable()
        {
            _sceneMode = SceneMode.None;
            _script = target as PathFinder;
            // ReSharper disable once PossibleNullReferenceException
            _script.graphData.ReGenerateIDs();
        }

        // When anything in inspector is changed, this will mark the scene or the prefab dirty
        private void MarkThisDirty()
        {
            if (Application.isPlaying)
                return;

            if (PrefabUtility.GetCorrespondingObjectFromSource(_script.gameObject) != null)
            {
                //QPathFinder.Logger.LogInfo ( "Prefab for PathFinder found! Marked it Dirty ( Modified )");
                EditorUtility.SetDirty(_script);
            }
            else
            {
                //QPathFinder.Logger.LogInfo ( "Prefab for PathFinder Not found! Marked the scene as Dirty ( Modified )");
                EditorSceneManager.MarkSceneDirty(SceneManager.GetActiveScene());
            }
        }


        private SceneMode _sceneMode;
        private PathFinder _script;

        private const string NodeGUITextColor = "#ff00ffff";
        private const string PathGUITextColor = "#00ffffff";
        private const string CostGUITextColor = "#0000ffff";

        private int _selectedNodeForConnectNodesMode = -1;
        private bool _showNodeIDsInTheScene = true;
        private bool _showPathIDsInTheScene = true;
        private bool _drawPathsInTheScene = true;
        private bool _showCostsInTheScene;
        private bool _showDefaultInspector;

        private static readonly int ShaderColor = Shader.PropertyToID("_Color");
        
        #endregion
    }
}