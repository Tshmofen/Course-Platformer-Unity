#define ONE_WAY_LOGIC

using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace ThirdParty.QPathFinder.Script
{
    public enum PathLineType
    {
        Straight,
        CatmullRomCurve,
    }

    //
    // Single Node. From which we can create Paths ( or connections )

    [System.Serializable]
    public class Node
    {
        public Node(Vector3 pos)
        {
            position = pos;
        }

        public void SetPosition(Vector3 pos)
        {
            position = pos;
        }

        public Vector3 Position => position;
        
        public float CombinedHeuristic => pathDistance + heuristicDistance;

        public void SetAsOpen(bool open)
        {
            isOpen = open;
        }

        public bool IsOpen => isOpen;

        [SerializeField] private Vector3 position;
        [SerializeField] private bool isOpen = true;
        [SerializeField] public int autoGeneratedID = -1;
        [HideInInspector] public Node previousNode;
        [HideInInspector] public float heuristicDistance;
        [HideInInspector] public float pathDistance;
    }

    //
    // Path is a connection between 2 Nodes. It will have zero cost by default unless specified in inspector.
    // A path can be a oneway too.

    [System.Serializable]
    public class Path
    {
        public Path(int a, int b)
        {
            idOfA = a; idOfB = b;
        }

        [SerializeField] public int cost;
        [SerializeField] public int autoGeneratedID;
        [SerializeField] public int idOfA;
        [SerializeField] public int idOfB;
        [SerializeField] public bool isOneWay;
        [SerializeField] public bool isOpen = true;
    }

    // A collection of Nodes and Paths ( Connections ).
    [System.Serializable]
    public class GraphData
    {
        [SerializeField] public PathLineType lineType;
        [SerializeField] public Color lineColor = Color.yellow;
        [SerializeField] public float nodeSize = 0.5f;
        // this represents how much offset we create our points from the ground ?
        [SerializeField] public float heightFromTheGround;      
        [SerializeField] public string groundColliderLayerName = "Default";

        [SerializeField] public List<Node> nodes;
        [SerializeField] public List<Path> paths;

        public Dictionary<int, Node> NodesSorted;
        public Dictionary<int, Path> PathsSorted;

        public GraphData()
        {
            nodes = new List<Node>();
            paths = new List<Path>();
            NodesSorted = new Dictionary<int, Node>();
            PathsSorted = new Dictionary<int, Path>();
        }

        public Node GetNode(int id)
        {
            return NodesSorted.ContainsKey(id) ? NodesSorted[id] : null;
        }

        public Path GetPath(int id)
        {
            return PathsSorted.ContainsKey(id) ? PathsSorted[id] : null;
        }

        public Path GetPathBetween(int from, int to)
        {
            return paths.FirstOrDefault(pd => 
                (pd.idOfA == @from && pd.idOfB == to) 
                || (pd.idOfB == @from && pd.idOfA == to)
                );
        }

        public Path GetPathBetween(Node from, Node to)
        {
            if (from == null | to == null)
                return null;

            return GetPathBetween(from.autoGeneratedID, to.autoGeneratedID);
        }

        public void ReGenerateIDs()
        {
            if (nodes == null)
                return;

            //Generate IDs for Nodes
            {
                var maxID = nodes.Select(t => t.autoGeneratedID).Prepend(0).Max() + 1;
                foreach (var node in nodes.Where(node => node.autoGeneratedID <= 0))
                {
                    node.autoGeneratedID = maxID++;
                }
            }

            // generate IDs for way paths.
            {
                var maxID = paths.Select(t => t.autoGeneratedID).Prepend(0).Max() + 1;
                foreach (var t in paths.Where(t => t.autoGeneratedID <= 0))
                {
                    t.autoGeneratedID = maxID++;
                }
            }

            // refreshing dictionaries
            {
                PathsSorted.Clear();
                NodesSorted.Clear();

                foreach (var node in nodes)
                {
                    NodesSorted[node.autoGeneratedID] = node;
                }

                foreach (var path in paths)
                {
                    PathsSorted[path.autoGeneratedID] = path;
                }
            }
        }
    }
}